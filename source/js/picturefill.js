/ *! Picturefill - v2.3.1 - 2015-04-09
* http://scottjehl.github.io/picturefill
* Авторские права (c) 2015 г. https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Лицензионный MIT * /
окно . matchMedia || ( window . matchMedia = function ( ) { "использовать строгий" ; var  a = window . styleMedia || window . media ; if ( ! a ) { var  b = document . createElement ( "style" ) , c = document . getElementsByTagName ( "скрипт" ) [0 ] , d = ноль ; б . type = "text / css" , b . id = "matchmediajs-test" , c . parentNode . insertBefore ( b , c ) , d = "getComputedStyle" в  окне && window . getComputedStyle ( b , null ) || б . currentStyle , a = {matchMedium : function ( a ) { var  c = "@media" + a + "{# matchmediajs-test {width: 1px;}}" ; возврат  б . таблица стилей ? б . таблица стилей . cssText = c : b . textContent = c , "1px" === d . width } } } функция возврата  ( b ) { return {совпадения : а . matchMedium ( b || "all" ) , медиа : b || "all" } } } ( ) ) , function ( a , b , c ) { "использовать строгий" ; function  d ( b ) { "object" == typeof  module && "object" == typeof  module . экспорт ? модуль .exports = b : "function" == typeof  define && define . amd && define ( "picturefill" , function ( ) { return  b } ) , "object" == typeof  a && ( a . picturefill = b ) } функция  e ( a ) { var  b , c , d , e ,f , i = a || { } ; б = я . элементы || г . getAllElements ( ) ; для ( var  j = 0 , k = b . length ; k > j ; j ++ ) if ( c = b [ j ] , d = c . parentNode , e =void  0 , f = void  0 , "IMG" === c . имя узла . toUpperCase ( ) && ( c [ g . ns ] || ( c [ g . ns ] = { } ) , т . е. переоценка || ! c [ g . ns ] . оцененный ) ) { if ( d&& "КАРТИНА" === d . имя узла . toUpperCase ( ) ) { if ( g . removeVideoShim ( d ) , e = g . getMatch ( c , d ) , e === ! 1 ) continue } else  e = void  0 ; ( d && "PICTURE" === d . nodeName .toUpperCase ( ) || ! г . Поддерживаемые размеры && c . srcset && h . test ( c . srcset ) ) && g . dodgeSrcset ( c ) , e ? ( f = g . processSourceSet ( e ) , g . applyBestCandidate ( f , c ) ) : ( f =г . processSourceSet ( c ) , ( void  0 === c . srcset || c [ g . ns ] . srcset ) && g . applyBestCandidate ( f , c ) ) , c [ g . нс ] . оценено = ! 0 } } function  f ( ) { function  c () { clearTimeout ( d ) , d = setTimeout ( h , 60 ) } g . initTypeDetects ( ) , e ( ) ; var  d , f = setInterval ( function ( ) { return  e ( ) , / ^ загружен | ^ i | ^ c / . test ( b .readyState ) ? void  clearInterval ( f ) : void  0 } , 250 ) , h = function ( ) { e ( { reevaluate :! 0 } ) } ; а . addEventListener ? а . addEventListener ( "изменить размер" , с , ! 1 ) : . attachEvent && a .attachEvent ( "onresize" , c ) } if ( a . HTMLPictureElement ) return  void  d ( function ( ) { } ) ; б . createElement ( "картинка" ) ; var  g = a . Picturefill || { } , h = / \ s + \ + ? \ d + ( e \ d + )? ш / ; г . ns = "picturefill" , function ( ) { g . srcsetSupported = "srcset" в  c , g . sizesSupported = «размеры» в  с , г . curSrcSupported = "currentSrc" в  c } ( ) , g . отделка = функция ( а ) { вернуть  а . обрезать ?а . отделка ( ) : а . заменить ( / ^ \ s + | \ s + $ / g , "" ) } , g . makeUrl = function ( ) { var  a = b . createElement ( "a" ) ; return  function ( b ) { return  a . href = b , a .HREF } } ( ) , г . limittsMixedContent = function ( ) { return "https:" === a . местоположение . Протокол } , г . matchMedia = function ( b ) { вернуть  a . matchMedia && a . matchMedia ( б ) . спички } , g . getDpr = function( ) { Возвращают  . devicePixelRatio || 1 } , г . getWidthFromLength = function ( a ) { var c ; if ( ! a || a . indexOf ( "%" ) > - 1 ! =! 1 || ! ( parseFloat ( a ) > 0 || a . indexOf ( "calc (" ) > - 1 ) ) вернись ! 1 ; а = а . заменить ( "vw" , "%" ) , g . длинаEl || ( g . lengthEl = b . createElement ( "div" ) , g . lengthEl . style . cssText = "border: 0; display: block; font-size: 1em; left: 0; margin: 0; padding: 0; position : абсолютная, видимость: скрытый» , г . lengthEl, className = "helper-from-picturefill-js" ) , g . длина эл . стиль . ширина = "0px" ; попробуйте { г . длина эл . стиль . width = a } catch ( d ) { } return  b . тело . appendChild ( g . lengthEl ) , c = g . длина эл . offsetWidth, 0 > = c && ( c = ! 1 ) , б . тело . removeChild ( g . lengthEl ) , c } , g . detectTypeSupport = function ( b , c ) { var  d = new  a . Изображение ; вернуться  д . onerror = function ( ) { g .типы [ b ] = ! 1 , e ( ) } , d . onload = function ( ) { g . типы [ b ] = 1 === d . ширина , е ( ) } , д . src = c , "pending" } , g . Типы = г . типы || { }, Г . initTypeDetects = function ( ) { g . types [ "image / jpeg" ] = ! 0 , г . types [ "image / gif" ] = ! 0 , г . types [ "image / png" ] = ! 0 , г . типы [ "image / svg + xml" ] = b . реализация . hasFeature («http://www.w3.org/TR/SVG11/feature#Image» , «1.1» ) , g . types [ "image / webp" ] = g . detectTypeSupport ( "image / webp" , "data: image / webp; base64, UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ // 73v / + BiOh / AAA =" ) } , g . verifyTypeSupport = function ( a ) { var  b = a . getAttribute ( "type" ) ; if ( null === b|| "" === б ) вернись ! 0 ; var  c = g . типы [ b ] ; вернуть "строку" == typeof  c && "в ожидании" ! == c ? ( g . types [ b ] = g . detectTypeSupport ( b , c ) , «pending» ) : «function» == typeof  c ? (c ( ) , "в ожидании" ) : c } , g . parseSize = function ( a ) { var  b = / ( \ ( [ ^) ] + \) ) ? \ S * ( . + ) / г . exec ( a ) ; return { media : b && b [ 1 ] , длина :b && b [ 2 ] } } , ж . findWidthFromSourceSize = function ( c ) { for ( var  d , e = g . trim ( c ) . split ( / \ s * , \ s * / ) , f = 0 , h = e . length ; h > f ; f++ ) { var  i = e [ f ] , j = g . parseSize ( i ) , k = j . длина , l = j . СМИ ; if ( k && ( ! l || g . matchMedia ( l ) ) && ( d = g . getWidthFromLength ( k )) ) break } return  d || Math . max ( a . innerWidth || 0 , b . documentElement . clientWidth ) } , g . parseSrcset = function ( a ) { for ( var  b = [ ] ; "" ! == a ; ) { a = a . заменить ( /^ \ s + / g , "" ) ; var  c , d = a . поиск ( / \ s / g ) , e = null ; if ( - 1 ! == d ) { c = a . срез ( 0 , д ) ; var  f = c . ломтик ( - 1 ) ; если ( ("," === f || "" === c ) && ( c = c . replace ( /, + $ / , "" ) , e = "" ) , a = a . срез ( d + 1 ) , ноль === e ) { var  g = a . indexOf ( "," ) ; - 1 ! ==г ? ( e = a . slice ( 0 , g ) , a = a . slice ( g + 1 ) ) : ( e = a , a = "" ) } } else  c = a , a = "" ; ( c || e ) && b . нажать ( { URL : C, дескриптор : e } ) } return  b } , g . parseDescriptor = function ( a , b ) { var  c , d = b || "100vw" , e = a && a . заменить ( / ( ^ \ s + | \ s + $ ) / g , "" ) , f = g, findWidthFromSourceSize ( d ) ; если ( e ) для ( var  h = e . split ( "" ) , i = h . length - 1 ; i > = 0 ; i - ) { var  j = h [ i ] , k = j && j . срез ( J . Длина- 1 ) ; if ( "h" ! == k && "w" ! == k || g . sizesSupported ) { if ( "x" === k ) { var  l = j && parseFloat ( j , 10 ) ; c = l && ! isNaN ( л ) ? l : 1 } } else  c = parseFloat( parseInt ( j , 10 ) / f ) } return  c || 1 } , г . getCandidatesFromSourceSet = function ( a , b ) { for ( var  c = g . parseSrcset ( a ) , d = [ ] , e = 0 , f = c . length ; f> е ; е ++ ) { var  h = c [ e ] ; д . push ( { url : h . url , разрешение : g . parseDescriptor ( h . descriptor , b ) } ) } return  d } , g . dodgeSrcset = function ( a ) { a .srcset && ( a [ g . ns ] . srcset = a . srcset , a . srcset = "" , a . setAttribute ( "data-pfsrcset" , a [ g . ns ] . srcset ) ) } , g . processSourceSet = function ( a ) { var  b = a . GetAttribute( "srcset" ) , c = a . getAttribute ( "sizes" ) , d = [ ] ; вернуть "IMG" === a . имя узла . toUpperCase ( ) && a [ g . ns ] && a [ g . нс ] . srcset && ( b = a [ g . ns ] . srcset) , b && ( d = g . getCandidatesFromSourceSet ( b , c ) ) , d } , g . backfaceVisibilityFix = function ( a ) { var  b = a . стиль || { } , c = "webkitBackfaceVisibility" в  b , d = b . зум ; c && ( b, zoom = ".999" , c = a . смещение ширины , б . масштаб = d ) } , г . setIntrinsicSize = function ( ) { var  c = { } , d = function ( a , b , c ) { b && a . setAttribute ( "width" , parseInt ( b/ с , 10 ) ) } ; функция возврата  ( e , f ) { var h ; e [ g . нс ] && ! а . pfStopIntrinsicSize && ( void 0 === e [ g . ns ] . dims && ( e [ g . ns ] . dims = e . getAttribute  ( "ширина" ) || эл . getAttribute ( "height" ) ) , e [ g . нс ] . тусклые || ( f . url  в  c ? d ( e , c [ f . url ] , f . resolution ) : ( h = b . createElement ( "img" ) , h .OnLoad = функция ( ) { если ( с [ е . URL ] = ч . ширина , ! с [ е . URL ] ) пытаются { Ь . тело . appendChild ( h ) , c [ f . url ] = h . ширина || ч . смещение ширины , б . тело .removeChild ( h ) } catch ( a ) { } e . src === f . url && d ( e , c [ f . url ] , f . resolution ) , e = null , h . onload = ноль , h = ноль } , h . src = f . URL) ) ) } } ( ) , Г . applyBestCandidate = function ( a , b ) { var  c , d , e ; а . sort ( g . ascendingSort ) , d = a . длина , е = а [ д - 1 ] ; для ( var  f = 0 ;d > f ; f ++ ) if ( c = a [ f ] , c . resolution > = g . getDpr ( ) ) { e = c ; break } e && ( e . url = g . makeUrl ( e . url ) , b . src ! == e . url && (г . limittsMixedContent ( ) && "http:" === e . URL . substr ( 0 , "http:" . length ) . toLowerCase ( ) ? void  0 ! == окно . консоль && console . warn ( "Заблокированное изображение со смешанным содержимым" + e . url ) : ( b . src = e . url , g, curSrcSupported || ( b . currentSrc = b . src ) , g . backfaceVisibilityFix ( b ) ) ) , g . setIntrinsicSize ( b , e ) ) } , g . ascendingSort = function ( a , b ) { вернуть  a . разрешение - б . разрешение } ,г . removeVideoShim = function ( a ) { var  b = a . getElementsByTagName ( "video" ) ; if ( b . length ) { for ( var  c = b [ 0 ] , d = c . getElementsByTagName ( "source" ) ; d . length ; ) a . insertBefore (d [ 0 ] , c ) ; с . parentNode . removeChild ( c ) } } , g . getAllElements = function ( ) { for ( var  a = [ ] , c = b . getElementsByTagName ( "img" ) , d = 0 , e = c . length ; e >г ; d ++ ) { var  f = c [ d ] ; ( "PICTURE" === е . ParentNode . NODENAME . ToUpperCase ( ) || нуль! == е . GetAttribute ( "srcset" ) || е [ г . Нс ] && нуль! == е [ г . Нс ] . srcset ) && a .push ( f ) } вернуть  a } , g . getMatch = function ( a , b ) { for ( var  c , d = b . childNodes , e = 0 , f = d . length ; f > e ; e ++ ) { var  h = d [ e ] ; если( 1 === h . NodeType ) { if ( h === a ) return  c ; if ( "SOURCE" === h . nodeName . toUpperCase ( ) ) { null! == h . getAttribute ( "src" ) && void  0 ! == typeof  console && console . предупредить («Атрибут` src` недопустим для элемента `picture`` source`; вместо этого используйте `srcset`." ) ; var  i = h . getAttribute ( "media" ) ; if ( h . getAttribute ( "srcset" ) && ( ! i || g . matchMedia ( i ) ) ) { var  j = g . verifyTypeSupport ( h ) ; если ( j === !0 ) { с = ч ; break } if ( "pending" === j ) вернитесь ! 1 } } } } return  c } , f ( ) , e . _ = g , d ( e ) } ( окно , окно . документ , новое  окно . Изображение ) ;
